<#
.SYNOPSIS
Create OpsGenie Alert.

.DESCRIPTION
Powershell wrapper function around OpsGenie API version 2 used to create alert.

.PARAMETER Message
Message of the alert - this will be shown as the main subject of the alert

.PARAMETER ApiKey
API Key of your OpsGenie HTTP/HTTPS Integration

.PARAMETER Alias
Client-defined identifier of the alert, that is also the key element of Alert De-Duplication - this parameter is usually generated by default, try ommiting it

.PARAMETER Description
Description field of the alert that is generally used to provide a detailed information about the alert

.PARAMETER Responders
Teams, users, escalations and schedules that the alert will be routed to send notifications. type field is mandatory for each item, where possible values are team, user, escalation and schedule
Responders parameter has to be in the format of user:type or id:type - where type has possible values: team,user,escalation,schedule

.PARAMETER VisibleTo
VisbleTo parameter has to be in the format of user:type or id:type - where type has possible values: team,user

.PARAMETER Actions
Custom actions that will be available for the alert - you can find it by clicking tripple dot button on the created alert
This parameter accepts array of values, like - action1,action2,action3

.PARAMETER Tags
Tags of the alert
This parameter accepts array of values, like - tag1,tag2,tag3

.PARAMETER Details
Map of key-value pairs to use as custom properties of the alert
Provide value to this parameter, like - detailname:detailvalue
This parameter accepts array of values, like - detailname1:detailvalue1,detailname2:detailvalue2

.PARAMETER Entity
Entity field of the alert that is generally used to specify which domain alert is related to

.PARAMETER Source
Source field of the alert. Default value is IP address of the incoming request

.PARAMETER Priority
Priority level of the alert. Possible values are P1, P2, P3, P4 and P5. Default value is P3

.PARAMETER User
Display name of the request owner

.PARAMETER Note
Additional note that will be added while creating the alert

.EXAMPLE
New-OpsGenieAlert -Message 'THIS IS TEST' -ApiKey $apiopsgenie -Tags standbyshift,testtag 

.EXAMPLE
New-OpsGenieAlert -Message 'THIS IS TEST' -ApiKey $apiopsgenie -Responders azure_team:team,azure_incident_schedule:schedule -Details detailsname:detailvalue -Source nemanjaworkstation -Priority P1 -User 'Nemanja Jovic' -Note 'this is note'

#>
Function New-OpsGenieAlert {
    [CmdletBinding()]
    param (
        # Message of the alert.
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [ValidateCount(0, 130)]
        [string]$Message,
        # ApiKey of your API HTTP/HTTPS integration.
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [string]$ApiKey,
        # Client-defined identifier of the alert, that is also the key element of Alert De-Duplication.
        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [ValidateCount(0, 512)]
        [string]$Alias,
        # Description field of the alert that is generally used to provide a detailed information about the alert.
        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [ValidateCount(0, 15000)]
        [string]$Description,
        # Teams, users, escalations and schedules that the alert will be routed to send notifications. type field is mandatory for each item, where possible values are team, user, escalation and schedule.
        # Responders parameter has to be in the format of user:type or id:type - where type has possible values: team,user,escalation,schedule
        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [ValidatePattern('.:.')]
        [ValidateCount(0, 50)]
        [string[]]$Responders,
        # VisbleTo parameter has to be in the format of user:type or id:type - where type has possible values: team,user
        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [ValidatePattern('.:.')]
        [ValidateCount(0, 50)]
        [string[]]$VisibleTo,
        # Custom actions that will be available for the alert.
        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [string[]]$Actions,
        # Tags of the alert.
        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [string[]]$Tags,
        # Map of key-value pairs to use as custom properties of the alert.
        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [ValidatePattern('.:.')]
        [string[]]$Details,
        # Entity field of the alert that is generally used to specify which domain alert is related to.
        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [ValidateCount(0, 512)]
        [string]$Entity,
        # Source field of the alert. Default value is IP address of the incoming request.
        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [ValidateCount(0, 100)]
        [string]$Source,
        # Priority level of the alert. Possible values are P1, P2, P3, P4 and P5. Default value is P3.
        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [ValidateSet('P1', 'P2', 'P3', 'P4', 'P5')]
        [string]$Priority,
        # Display name of the request owner.
        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [ValidateCount(0, 100)]
        [string]$User,
        # Additional note that will be added while creating the alert.
        [Parameter(Mandatory = $false)]
        [ValidateNotNullOrEmpty()]
        [string]$Note
    )
    process {
        $Body = [PSCustomObject]@{
        }
        $Body | Add-Member -MemberType NoteProperty -Name message -Value $Message
        if ($Responders) {
            $ResponderFinalCollection = [System.Collections.ArrayList]::new()
            $ResponderList = $Responders.Split(',')
            $TypeList = 'team', 'user', 'escalation', 'schedule'
            foreach ($Responder in $ResponderList) {
                [array]$SplitResponder = $Responder.Split(':')
                $ResponderHash = @{ }
                if ($TypeList -notcontains $SplitResponder[1]) {
                    Write-Error "Responders type field must match one of the following - $TypeList" -ErrorAction Stop
                }
                if ($SplitResponder[0].Length -eq '36' -and $SplitResponder[0] -match '.*-.*-.*-.*-.*') {
                    $ResponderHash.Add('id', $SplitResponder[0])
                    $ResponderHash.Add('type', $SplitResponder[1])
                }
                else {
                    $ResponderHash.Add('name', $SplitResponder[0])
                    $ResponderHash.Add('type', $SplitResponder[1])
                }
                [void]$ResponderFinalCollection.Add($ResponderHash)

            }
            $Body | Add-Member -MemberType noteproperty -Name responders -Value $ResponderFinalCollection
        }
        if ($VisibleTo) {
            $VisibleToFinalCollection = [System.Collections.ArrayList]::new()
            [array]$VisibleList = $VisibleTo.Split(',')
            $TypeList = 'team', 'user'
            foreach ($Item in $VisibleList) {
                $SplitVisible = $Item.Split(':')
                $VisibleHash = @{ }
                if ($TypeList -notcontains $SplitVisible[1]) {
                    Write-Error "VisibleTo type field must match one of the following - $TypeList" -ErrorAction Stop
                }
                if ($SplitVisible[0].Length -eq '36' -and $SplitVisible[0] -match '.*-.*-.*-.*-.*') {
                    $VisibleHash.Add('id', $SplitVisible[0])
                    $VisibleHash.Add('type', $SplitVisible[1])
                }
                else {
                    $VisibleHash.Add('name', $SplitVisible[0])
                    $VisibleHash.Add('type', $SplitVisible[1])
                }
                [void]$VisibleToFinalCollection.Add($VisibleHash)
            }
            $Body | Add-Member -MemberType noteproperty -Name visibleto -Value $VisibleToFinalCollection
        }
        $ArrayParameters = 'actions', 'tags'
        foreach ($Item in $ArrayParameters) {
            $ErrorActionPreference = 'SilentlyContinue'
            if ($PSBoundParameters.$($Item)) {
                $ItemFinalCollection = [System.Collections.ArrayList]::new()
                $SplitedItem = $PSBoundParameters.$($Item).Split(',')
                foreach ($Member in $SplitedItem) {
                    [void]$ItemFinalCollection.Add($Member)
                }
                $Body | Add-Member -MemberType NoteProperty -Name $Item -Value $ItemFinalCollection
            }
        }
        if ($Details) {
            $DetailsHash = @{ }
            $SplitedDetais = $Details.Split(',')
            foreach ($ItemDetail in $SplitedDetais) {
                $ColumnSplitedDetails = $ItemDetail.Split(':')
                $DetailsHash.Add($ColumnSplitedDetails[0], $ColumnSplitedDetails[1])
            }
            $Body | Add-Member -MemberType NoteProperty -Name 'details' -Value $DetailsHash
        }
        $SingleParameters = 'entity', 'source', 'priority', 'user', 'note', 'description', 'alias'
        foreach ($Item in $SingleParameters) {
            $ErrorActionPreference = 'SilentlyContinue'
            if ($PSBoundParameters.$($Item)) {
                $Body | Add-Member -MemberType NoteProperty -Name $Item -Value $PSBoundParameters.$($Item)
            }
        }
        $ToSend = $Body | ConvertTo-Json
        $ErrorActionPreference = 'Continue'
        $Headers = @{
            'Authorization' = "GenieKey $($ApiKey)"
        }
        $RestSplat = @{
            Method      = 'Post'
            Uri         = 'https://api.opsgenie.com/v2/alerts'
            Body        = $ToSend
            Headers     = $Headers
            ContentType = 'application/json'
            UseBasicParsing = $true
        }
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
        Invoke-WebRequest @RestSplat
    }   
}